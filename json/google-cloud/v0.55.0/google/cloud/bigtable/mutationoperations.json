{"id":"google/cloud/bigtable/mutationoperations","name":"MutationOperations","title":["Google","Cloud","Bigtable","MutationOperations"],"description":"<h1 id=\"mutationoperations\">MutationOperations</h1>\n\n<p>Collection of mutations apis.</p>\n\n<ul>\n  <li>Mutate single row</li>\n  <li>Mutate multiple rows</li>\n  <li>Read modify and write row atomically on the server</li>\n  <li>Check and mutate row</li>\n</ul>","source":"google-cloud-bigtable/lib/google/cloud/bigtable/mutation_operations.rb#L35","resources":[],"examples":[],"methods":[{"id":"mutate_row-instance","type":"instance","name":"mutate_row","title":["Google","Cloud","Bigtable","MutationOperations#mutate_row"],"description":"<p>Mutate row.</p>\n\n<p>Mutates a row atomically. Cells already present in the row are left\nunchanged unless explicitly changed by +mutation+.\nChanges to be atomically applied to the specified row. Entries are applied\nin order, meaning that earlier mutations can be masked by later ones.\nMust contain at least one mutation entry and at most 100000.</p>","source":"google-cloud-bigtable/lib/google/cloud/bigtable/mutation_operations.rb#L75","resources":[],"examples":[{"caption":"<p>Single mutation on row.</p>","code":"require \"google/cloud\"\n\nbigtable = Google::Cloud::Bigtable.new\n\ntable = bigtable.table(\"my-instance\", \"my-table\")\n\nentry = table.new_mutation_entry.new(\"user-1\")\nentry.set_cell(\"cf1\", \"field1\", \"XYZ\")\ntable.mutate_row(entry)"},{"caption":"<p>Multiple mutations on row.</p>","code":"require \"google/cloud\"\n\nbigtable = Google::Cloud::Bigtable.new\n\ntable = bigtable.table(\"my-instance\", \"my-table\")\n\nentry = table.new_mutation_entry(\"user-1\")\nentry.set_cell(\n  \"cf-1\",\n  \"field-1\",\n  \"XYZ\"\n  timestamp: Time.now.to_i * 1000 # Time stamp in milli seconds.\n).delete_from_column(\"cf2\", \"field02\")\n\ntable.mutate_row(entry)"}],"params":[{"name":"entry","types":["Google::Cloud::Bigtable::MutationEntry"],"description":"Mutation entry with row key and list of mutations.","optional":false,"nullable":false}],"exceptions":[],"returns":[{"types":["Boolean"],"description":""}]},{"id":"mutate_rows-instance","type":"instance","name":"mutate_rows","title":["Google","Cloud","Bigtable","MutationOperations#mutate_rows"],"description":"<p>Mutates multiple rows in a batch. Each individual row is mutated\natomically as in MutateRow, but the entire batch is not executed\natomically.</p>","source":"google-cloud-bigtable/lib/google/cloud/bigtable/mutation_operations.rb#L109","resources":[],"examples":[{"caption":"","code":"require \"google/cloud\"\n\nbigtable = Google::Cloud::Bigtable.new\n\ntable = bigtable.table(\"my-instance\", \"my-table\")\n\nentries = []\nentries << table.new_mutation_entry(\"row-1\").set_cell(\"cf1\", \"field1\", \"XYZ\")\nentries << table.new_mutation_entry(\"row-2\").set_cell(\"cf1\", \"field1\", \"ABC\")\ntable.mutate_row(entries)"}],"params":[{"name":"entries","types":["Array<Google::Cloud::Bigtable::MutationEntry>"],"description":"The row keys and corresponding mutations to be applied in bulk.\nEach entry is applied as an atomic mutation, but the entries may be\napplied in arbitrary order (even between entries for the same row).\nAt least one entry must be specified, and in total the entries can\ncontain at most 100000 mutations.","optional":false,"nullable":false}],"exceptions":[],"returns":[{"types":["Array&lt;<a data-custom-type=\"google/bigtable/v2/mutaterowsresponse/entry\">Google::Bigtable::V2::MutateRowsResponse::Entry</a>&gt;"],"description":""}]},{"id":"read_modify_write_row-instance","type":"instance","name":"read_modify_write_row","title":["Google","Cloud","Bigtable","MutationOperations#read_modify_write_row"],"description":"<p>Modifies a row atomically on the server. The method reads the latest\nexisting timestamp and value from the specified columns and writes a new\nentry based on pre-defined read/modify/write rules. The new value for the\ntimestamp is the greater of the existing timestamp or the current server\ntime. The method returns the new contents of all modified cells.</p>","source":"google-cloud-bigtable/lib/google/cloud/bigtable/mutation_operations.rb#L154","resources":[],"examples":[{"caption":"<p>Apply multiple modification rules.</p>","code":"require \"google/cloud/bigtable\"\n\nbigtable = Google::Cloud::Bigtable.new\ntable = bigtable.table(\"my-instance\", \"my-table\")\n\nrule_1 = table.new_read_modify_write_rule(\"cf\", \"field01\")\nrule_1.append(\"append-xyz\")\n\nrule_2 = table.new_read_modify_write_rule(\"cf\", \"field01\")\nrule_2.increment(1)\n\nrow = table.read_modify_write_row(\"user01\", [rule_1, rule_2])\n\nputs row.cells"},{"caption":"<p>Apply single modification rules.</p>","code":"require \"google/cloud/bigtable\"\n\nbigtable = Google::Cloud::Bigtable.new\ntable = bigtable.table(\"my-instance\", \"my-table\")\n\nrule = table.new_read_modify_write_rule(\"cf\", \"field01\").append(\"append-xyz\")\n\nrow = table.read_modify_write_row(\"user01\", rule)\n\nputs row.cells"}],"params":[{"name":"key","types":["String"],"description":"The key of the row to which the read/modify/write rules should be applied.","optional":false,"nullable":false},{"name":"rules","types":["Google::Cloud::Bigtable::ReadModifyWriteRule","Array<Google::Cloud::Bigtable::ReadModifyWriteRule>"],"description":"Rules specifying how the specified rowâ€™s contents are to be transformed\ninto writes. Entries are applied in order, meaning that earlier rules will\naffect the results of later ones.","optional":false,"nullable":false}],"exceptions":[],"returns":[{"types":["<a data-custom-type=\"google/cloud/bigtable/row\">Google::Cloud::Bigtable::Row</a>"],"description":""}]},{"id":"check_and_mutate_row-instance","type":"instance","name":"check_and_mutate_row","title":["Google","Cloud","Bigtable","MutationOperations#check_and_mutate_row"],"description":"<p>Mutates a row atomically based on the output of a predicate Reader filter.</p>\n\n<p>NOTE: Condition predicate filter is not supported.</p>","source":"google-cloud-bigtable/lib/google/cloud/bigtable/mutation_operations.rb#L234","resources":[],"examples":[{"caption":"","code":"require \"google/cloud/bigtable\"\n\nbigtable = Google::Cloud::Bigtable.new\ntable = bigtable.table(\"my-instance\", \"my-table\")\n\npredicate_filter = Google::Cloud::Bigtable::RowFilter.key(\"user-10\")\non_match_mutations = Google::Cloud::Bigtable::MutationEntry.new\non_match_mutations.set_cell(\n  \"cf-1\",\n  \"field-1\",\n  \"XYZ\",\n  timestamp: Time.now.to_i * 1000 # Time stamp in micro seconds.\n).delete_from_column(\"cf2\", \"field02\")\n\notherwise_mutations = Google::Cloud::Bigtable::MutationEntry.new\notherwise_mutations.delete_from_family(\"cf3\")\n\nresponse = table.check_and_mutate_row(\n  \"user01\",\n  predicate_filter,\n  on_match: on_match_mutations,\n  otherwise: otherwise_mutations\n)\n\nif response\n  puts \"All predicates matched\"\nend"}],"params":[{"name":"key","types":["String"],"description":"Row key.\nThe key of the row to which the conditional mutation should be applied.","optional":false,"nullable":false},{"name":"predicate","types":["SimpleFilter","ChainFilter","InterleaveFilter"],"description":"Predicate filter.\nThe filter to be applied to the contents of the specified row. Depending\non whether or not any results are yielded, either +true_mutations+ or\n+false_mutations+ will be executed. If unset, checks that the row contains\nany values at all.","optional":false,"nullable":false},{"name":"on_match","types":["Google::Cloud::Bigtable::MutationEntry"],"description":"Mutation entry apply on predicate filter match.\nChanges to be atomically applied to the specified row if +predicate_filter+\nyields at least one cell when applied to +row_key+. Entries are applied in\norder, meaning that earlier mutations can be masked by later ones.\nMust contain at least one entry if +false_mutations+ is empty, and at most\n100000.","optional":true,"default":"nil","nullable":true},{"name":"otherwise","types":["Google::Cloud::Bigtable::MutationEntry"],"description":"Mutation entry apply on predicate filter do not match.\nChanges to be atomically applied to the specified row if +predicate_filter+\ndoes not yield any cells when applied to +row_key+. Entries are applied in\norder, meaning that earlier mutations can be masked by later ones.\nMust contain at least one entry if +true_mutations+ is empty, and at most\n100000.","optional":true,"default":"nil","nullable":true}],"exceptions":[],"returns":[{"types":["Boolean"],"description":"Predicate match or not status"}]},{"id":"sample_row_keys-instance","type":"instance","name":"sample_row_keys","title":["Google","Cloud","Bigtable","MutationOperations#sample_row_keys"],"description":"<p>Read sample row keys.</p>\n\n<p>Returns a sample of row keys in the table. The returned row keys will\ndelimit contiguous sections of the table of approximately equal size,\nwhich can be used to break up the data for distributed tasks like\nmapreduces.</p>","source":"google-cloud-bigtable/lib/google/cloud/bigtable/mutation_operations.rb#L274","resources":[],"examples":[{"caption":"","code":"require \"google/cloud\"\n\nbigtable = Google::Cloud::Bigtable.new\ntable = bigtable.table(\"my-instance\", \"my-table\")\n\ntable.sample_row_keys.each do |sample_row_key|\n  p sample_row_key.key # user00116\n  p sample_row_key.offset # 805306368\nend"}],"params":[],"exceptions":[],"returns":[{"types":[":yields: sample_row_key"],"description":"Yield block for each processed SampleRowKey."}]},{"id":"new_mutation_entry-instance","type":"instance","name":"new_mutation_entry","title":["Google","Cloud","Bigtable","MutationOperations#new_mutation_entry"],"description":"<p>Create instance of mutation_entry</p>","source":"google-cloud-bigtable/lib/google/cloud/bigtable/mutation_operations.rb#L303","resources":[],"examples":[{"caption":"","code":"require \"google/cloud/bigtable\"\n\nbigtable = Google::Cloud::Bigtable.new\ntable = bigtable.table(\"my-instance\", \"my-table\")\n\nentry = table.new_mutation_entry(\"row-key-1\")\n\n# Without row key\nentry = table.new_mutation_entry"}],"params":[{"name":"row_key","types":["String"],"description":"Row key. Optional\nThe key of the row to which the mutation should be applied.","optional":true,"default":"nil","nullable":true}],"exceptions":[],"returns":[{"types":["<a data-custom-type=\"google/cloud/bigtable/mutationentry\">Google::Cloud::Bigtable::MutationEntry</a>"],"description":""}]},{"id":"new_read_modify_write_rule-instance","type":"instance","name":"new_read_modify_write_rule","title":["Google","Cloud","Bigtable","MutationOperations#new_read_modify_write_rule"],"description":"<p>Create instance of ReadModifyWriteRule to append or increment value\nof the cell qualifier.</p>","source":"google-cloud-bigtable/lib/google/cloud/bigtable/mutation_operations.rb#L332","resources":[],"examples":[{"caption":"<p>Create rule to append to qualifier value.</p>","code":"require \"google/cloud/bigtable\"\n\nbigtable = Google::Cloud::Bigtable.new\ntable = bigtable.table(\"my-instance\", \"my-table\")\nrule = table.new_read_modify_write_rule(\"cf\", \"qualifier-1\")\nrule.append(\"append-xyz\")"},{"caption":"<p>Create rule to increment qualifier value.</p>","code":"require \"google/cloud/bigtable\"\n\nbigtable = Google::Cloud::Bigtable.new\ntable = bigtable.table(\"my-instance\", \"my-table\")\nrule = table.new_read_modify_write_rule(\"cf\", \"qualifier-1\")\nrule.increment(100)"}],"params":[{"name":"family","types":["String"],"description":"The name of the family to which the read/modify/write should be applied.","optional":false,"nullable":false},{"name":"qualifier","types":["String"],"description":"The qualifier of the column to which the read/modify/write should be","optional":false,"nullable":false}],"exceptions":[],"returns":[{"types":["<a data-custom-type=\"google/cloud/bigtable/readmodifywriterule\">Google::Cloud::Bigtable::ReadModifyWriteRule</a>"],"description":""}]}]}