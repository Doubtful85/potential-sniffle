{"id":"google/spanner/v1/transactionoptions","name":"TransactionOptions","title":["Google","Spanner","V1","TransactionOptions"],"description":"<p>= Transactions</p>\n\n<p>Each session can have at most one active transaction at a time. After the\nactive transaction is completed, the session can immediately be\nre-used for the next transaction. It is not necessary to create a\nnew session for each transaction.</p>\n\n<p>= Transaction Modes</p>\n\n<p>Cloud Spanner supports two transaction modes:</p>\n\n<ol>\n  <li>\n    <p>Locking read-write. This type of transaction is the only way\nto write data into Cloud Spanner. These transactions rely on\npessimistic locking and, if necessary, two-phase commit.\nLocking read-write transactions may abort, requiring the\napplication to retry.</p>\n  </li>\n  <li>\n    <p>Snapshot read-only. This transaction type provides guaranteed\nconsistency across several reads, but does not allow\nwrites. Snapshot read-only transactions can be configured to\nread at timestamps in the past. Snapshot read-only\ntransactions do not need to be committed.</p>\n  </li>\n</ol>\n\n<p>For transactions that only read, snapshot read-only transactions\nprovide simpler semantics and are almost always faster. In\nparticular, read-only transactions do not take locks, so they do\nnot conflict with read-write transactions. As a consequence of not\ntaking locks, they also do not abort, so retry loops are not needed.</p>\n\n<p>Transactions may only read/write data in a single database. They\nmay, however, read/write data in different tables within that\ndatabase.</p>\n\n<p>== Locking Read-Write Transactions</p>\n\n<p>Locking transactions may be used to atomically read-modify-write\ndata anywhere in a database. This type of transaction is externally\nconsistent.</p>\n\n<p>Clients should attempt to minimize the amount of time a transaction\nis active. Faster transactions commit with higher probability\nand cause less contention. Cloud Spanner attempts to keep read locks\nactive as long as the transaction continues to do reads, and the\ntransaction has not been terminated by\nGoogle::Spanner::V1::Spanner::Commit or\nGoogle::Spanner::V1::Spanner::Rollback.  Long periods of\ninactivity at the client may cause Cloud Spanner to release a\ntransaction’s locks and abort it.</p>\n\n<p>Reads performed within a transaction acquire locks on the data\nbeing read. Writes can only be done at commit time, after all reads\nhave been completed.\nConceptually, a read-write transaction consists of zero or more\nreads or SQL queries followed by\nGoogle::Spanner::V1::Spanner::Commit. At any time before\nGoogle::Spanner::V1::Spanner::Commit, the client can send a\nGoogle::Spanner::V1::Spanner::Rollback request to abort the\ntransaction.</p>\n\n<p>=== Semantics</p>\n\n<p>Cloud Spanner can commit the transaction if all read locks it acquired\nare still valid at commit time, and it is able to acquire write\nlocks for all writes. Cloud Spanner can abort the transaction for any\nreason. If a commit attempt returns +ABORTED+, Cloud Spanner guarantees\nthat the transaction has not modified any user data in Cloud Spanner.</p>\n\n<p>Unless the transaction commits, Cloud Spanner makes no guarantees about\nhow long the transaction’s locks were held for. It is an error to\nuse Cloud Spanner locks for any sort of mutual exclusion other than\nbetween Cloud Spanner transactions themselves.</p>\n\n<p>=== Retrying Aborted Transactions</p>\n\n<p>When a transaction aborts, the application can choose to retry the\nwhole transaction again. To maximize the chances of successfully\ncommitting the retry, the client should execute the retry in the\nsame session as the original attempt. The original session’s lock\npriority increases with each consecutive abort, meaning that each\nattempt has a slightly better chance of success than the previous.</p>\n\n<p>Under some circumstances (e.g., many transactions attempting to\nmodify the same row(s)), a transaction can abort many times in a\nshort period before successfully committing. Thus, it is not a good\nidea to cap the number of retries a transaction can attempt;\ninstead, it is better to limit the total amount of wall time spent\nretrying.</p>\n\n<p>=== Idle Transactions</p>\n\n<p>A transaction is considered idle if it has no outstanding reads or\nSQL queries and has not started a read or SQL query within the last 10\nseconds. Idle transactions can be aborted by Cloud Spanner so that they\ndon’t hold on to locks indefinitely. In that case, the commit will\nfail with error +ABORTED+.</p>\n\n<p>If this behavior is undesirable, periodically executing a simple\nSQL query in the transaction (e.g., +SELECT 1+) prevents the\ntransaction from becoming idle.</p>\n\n<p>== Snapshot Read-Only Transactions</p>\n\n<p>Snapshot read-only transactions provides a simpler method than\nlocking read-write transactions for doing several consistent\nreads. However, this type of transaction does not support writes.</p>\n\n<p>Snapshot transactions do not take locks. Instead, they work by\nchoosing a Cloud Spanner timestamp, then executing all reads at that\ntimestamp. Since they do not acquire locks, they do not block\nconcurrent read-write transactions.</p>\n\n<p>Unlike locking read-write transactions, snapshot read-only\ntransactions never abort. They can fail if the chosen read\ntimestamp is garbage collected; however, the default garbage\ncollection policy is generous enough that most applications do not\nneed to worry about this in practice.</p>\n\n<p>Snapshot read-only transactions do not need to call\nGoogle::Spanner::V1::Spanner::Commit or\nGoogle::Spanner::V1::Spanner::Rollback (and in fact are not\npermitted to do so).</p>\n\n<p>To execute a snapshot transaction, the client specifies a timestamp\nbound, which tells Cloud Spanner how to choose a read timestamp.</p>\n\n<p>The types of timestamp bound are:</p>\n\n<ul>\n  <li>Strong (the default).\n    <ul>\n      <li>Bounded staleness.</li>\n      <li>Exact staleness.</li>\n    </ul>\n\n    <p>If the Cloud Spanner database to be read is geographically distributed,\nstale read-only transactions can execute more quickly than strong\nor read-write transaction, because they are able to execute far\nfrom the leader replica.</p>\n  </li>\n</ul>\n\n<p>Each type of timestamp bound is discussed in detail below.</p>\n\n<p>=== Strong</p>\n\n<p>Strong reads are guaranteed to see the effects of all transactions\nthat have committed before the start of the read. Furthermore, all\nrows yielded by a single read are consistent with each other – if\nany part of the read observes a transaction, all parts of the read\nsee the transaction.</p>\n\n<p>Strong reads are not repeatable: two consecutive strong read-only\ntransactions might return inconsistent results if there are\nconcurrent writes. If consistency across reads is required, the\nreads should be executed within a transaction or at an exact read\ntimestamp.</p>\n\n<p>See Google::Spanner::V1::TransactionOptions::ReadOnly#strong.</p>\n\n<p>=== Exact Staleness</p>\n\n<p>These timestamp bounds execute reads at a user-specified\ntimestamp. Reads at a timestamp are guaranteed to see a consistent\nprefix of the global transaction history: they observe\nmodifications done by all transactions with a commit timestamp &lt;=\nthe read timestamp, and observe none of the modifications done by\ntransactions with a larger commit timestamp. They will block until\nall conflicting transactions that may be assigned commit timestamps\n&lt;= the read timestamp have finished.</p>\n\n<p>The timestamp can either be expressed as an absolute Cloud Spanner commit\ntimestamp or a staleness relative to the current time.</p>\n\n<p>These modes do not require a “negotiation phase” to pick a\ntimestamp. As a result, they execute slightly faster than the\nequivalent boundedly stale concurrency modes. On the other hand,\nboundedly stale reads usually return fresher results.</p>\n\n<p>See Google::Spanner::V1::TransactionOptions::ReadOnly#read_timestamp and\nGoogle::Spanner::V1::TransactionOptions::ReadOnly#exact_staleness.</p>\n\n<p>=== Bounded Staleness</p>\n\n<p>Bounded staleness modes allow Cloud Spanner to pick the read timestamp,\nsubject to a user-provided staleness bound. Cloud Spanner chooses the\nnewest timestamp within the staleness bound that allows execution\nof the reads at the closest available replica without blocking.</p>\n\n<p>All rows yielded are consistent with each other – if any part of\nthe read observes a transaction, all parts of the read see the\ntransaction. Boundedly stale reads are not repeatable: two stale\nreads, even if they use the same staleness bound, can execute at\ndifferent timestamps and thus return inconsistent results.</p>\n\n<p>Boundedly stale reads execute in two phases: the first phase\nnegotiates a timestamp among all replicas needed to serve the\nread. In the second phase, reads are executed at the negotiated\ntimestamp.</p>\n\n<p>As a result of the two phase execution, bounded staleness reads are\nusually a little slower than comparable exact staleness\nreads. However, they are typically able to return fresher\nresults, and are more likely to execute at the closest replica.</p>\n\n<p>Because the timestamp negotiation requires up-front knowledge of\nwhich rows will be read, it can only be used with single-use\nread-only transactions.</p>\n\n<p>See Google::Spanner::V1::TransactionOptions::ReadOnly#max_staleness and\nGoogle::Spanner::V1::TransactionOptions::ReadOnly#min_read_timestamp.</p>\n\n<p>=== Old Read Timestamps and Garbage Collection</p>\n\n<p>Cloud Spanner continuously garbage collects deleted and overwritten data\nin the background to reclaim storage space. This process is known\nas “version GC”. By default, version GC reclaims versions after they\nare one hour old. Because of this, Cloud Spanner cannot perform reads\nat read timestamps more than one hour in the past. This\nrestriction also applies to in-progress reads and/or SQL queries whose\ntimestamp become too old while executing. Reads and SQL queries with\ntoo-old read timestamps fail with the error +FAILED_PRECONDITION+.</p>","source":"google-cloud-spanner/lib/google/cloud/spanner/v1/doc/google/spanner/v1/transaction.rb#L248","resources":[],"examples":[],"methods":[{"id":"read_write-instance","type":"instance","name":"read_write","title":["Google","Spanner","V1","TransactionOptions#read_write"],"description":"","source":"google-cloud-spanner/lib/google/cloud/spanner/v1/doc/google/spanner/v1/transaction.rb#L248","resources":[],"examples":[],"params":[],"exceptions":[],"returns":[{"types":["<a data-custom-type=\"google/spanner/v1/transactionoptions/readwrite\">Google::Spanner::V1::TransactionOptions::ReadWrite</a>"],"description":"Transaction may write.</p>\n\n<p>Authorization to begin a read-write transaction requires\n+spanner.databases.beginOrRollbackReadWriteTransaction+ permission\non the +session+ resource."}]},{"id":"read_write=-instance","type":"instance","name":"read_write=","title":["Google","Spanner","V1","TransactionOptions#read_write="],"description":"","source":"google-cloud-spanner/lib/google/cloud/spanner/v1/doc/google/spanner/v1/transaction.rb#L248","resources":[],"examples":[],"params":[],"exceptions":[],"returns":[{"types":["<a data-custom-type=\"google/spanner/v1/transactionoptions/readwrite\">Google::Spanner::V1::TransactionOptions::ReadWrite</a>"],"description":"Transaction may write.</p>\n\n<p>Authorization to begin a read-write transaction requires\n+spanner.databases.beginOrRollbackReadWriteTransaction+ permission\non the +session+ resource."}]},{"id":"read_only-instance","type":"instance","name":"read_only","title":["Google","Spanner","V1","TransactionOptions#read_only"],"description":"","source":"google-cloud-spanner/lib/google/cloud/spanner/v1/doc/google/spanner/v1/transaction.rb#L248","resources":[],"examples":[],"params":[],"exceptions":[],"returns":[{"types":["<a data-custom-type=\"google/spanner/v1/transactionoptions/readonly\">Google::Spanner::V1::TransactionOptions::ReadOnly</a>"],"description":"Transaction will not write.</p>\n\n<p>Authorization to begin a read-only transaction requires\n+spanner.databases.beginReadOnlyTransaction+ permission\non the +session+ resource."}]},{"id":"read_only=-instance","type":"instance","name":"read_only=","title":["Google","Spanner","V1","TransactionOptions#read_only="],"description":"","source":"google-cloud-spanner/lib/google/cloud/spanner/v1/doc/google/spanner/v1/transaction.rb#L248","resources":[],"examples":[],"params":[],"exceptions":[],"returns":[{"types":["<a data-custom-type=\"google/spanner/v1/transactionoptions/readonly\">Google::Spanner::V1::TransactionOptions::ReadOnly</a>"],"description":"Transaction will not write.</p>\n\n<p>Authorization to begin a read-only transaction requires\n+spanner.databases.beginReadOnlyTransaction+ permission\non the +session+ resource."}]}]}